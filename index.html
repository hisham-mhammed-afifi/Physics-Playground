<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Physics Playground â€” Complete Game</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body {
        background: #eef;
        margin: 0;
        overflow: hidden;
        font-family: system-ui, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 8px;
      }
      #controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      label {
        user-select: none;
      }
      canvas {
        background: #cde;
        border: 1px solid #888;
        touch-action: none;
        max-width: 100%;
        height: auto;
      }
      button {
        padding: 6px 10px;
      }
      .stat {
        margin-left: 8px;
        font-weight: 600;
      }
      #overlay {
        position: absolute;
        top: 45%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 16px 24px;
        border-radius: 8px;
        font-size: 1.2em;
        display: none;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label
        >Angle: <input id="angle" type="range" min="10" max="80" value="45"
      /></label>
      <label
        >Power: <input id="power" type="range" min="10" max="100" value="50"
      /></label>
      <button id="launchBtn">Launch</button>
      <button id="resetBtn">Reset</button>
      <span id="levelDisplay" class="stat">Level: 1</span>
      <span id="scoreDisplay" class="stat">Score: 0</span>
      <span id="triesDisplay" class="stat">Tries Left: 0</span>
      <span id="highScoreDisplay" class="stat">High Score: 0</span>
    </div>

    <canvas id="game" width="800" height="600"></canvas>
    <div id="overlay"></div>

    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
    <script>
      const { Engine, Runner, Bodies, Body, Composite, Events } = Matter;
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const engine = Engine.create();
      const world = engine.world;
      const runner = Runner.create();
      Runner.run(runner, engine);

      const VELOCITY_SCALE = 0.5;
      const launcherPos = { x: 100, y: 550 };
      const ground = Bodies.rectangle(400, 590, 800, 20, { isStatic: true });
      const leftWall = Bodies.rectangle(0, 300, 20, 600, { isStatic: true });
      const rightWall = Bodies.rectangle(800, 300, 20, 600, { isStatic: true });
      Composite.add(world, [ground, leftWall, rightWall]);

      const angleSlider = document.getElementById("angle");
      const powerSlider = document.getElementById("power");
      const launchBtn = document.getElementById("launchBtn");
      const resetBtn = document.getElementById("resetBtn");
      const levelDisplay = document.getElementById("levelDisplay");
      const scoreDisplay = document.getElementById("scoreDisplay");
      const triesDisplay = document.getElementById("triesDisplay");
      const highScoreDisplay = document.getElementById("highScoreDisplay");
      const overlay = document.getElementById("overlay");

      // Sounds (Web Audio API)
      function playSound(freq, type = "sine", duration = 0.2, vol = 0.2) {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.frequency.value = freq;
        osc.type = type;
        gain.gain.value = vol;
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
      }

      // Game state
      let level = 1,
        score = 0,
        highScore = parseInt(
          localStorage.getItem("physicsPlaygroundHighScore") || "0"
        );
      let projectile = null,
        launched = false,
        triesLeft = 0,
        targets = [],
        obstacles = [];
      let particles = []; // for explosions
      highScoreDisplay.textContent = `High Score: ${highScore}`;

      // Levels
      const LEVELS = [
        {
          targets: [
            { x: 600, y: 540 },
            { x: 650, y: 480 },
            { x: 700, y: 420 },
          ],
          obstacles: [
            { x: 400, y: 530, w: 100, h: 20, angle: 0 },
            { x: 500, y: 460, w: 120, h: 20, angle: Math.PI / 8 },
          ],
        },
        {
          targets: [
            { x: 600, y: 500 },
            { x: 680, y: 450 },
            { x: 730, y: 400 },
          ],
          obstacles: [
            { x: 430, y: 520, w: 140, h: 20, angle: -Math.PI / 10 },
            { x: 500, y: 470, w: 100, h: 20, angle: Math.PI / 6 },
          ],
        },
        {
          targets: [
            { x: 650, y: 520 },
            { x: 700, y: 460 },
            { x: 750, y: 400 },
          ],
          obstacles: [
            { x: 420, y: 530, w: 120, h: 20, angle: Math.PI / 8 },
            { x: 550, y: 460, w: 150, h: 20, angle: -Math.PI / 8 },
          ],
        },
      ];

      // Build level
      function buildLevel(n) {
        Composite.clear(world, false);
        Composite.add(world, [ground, leftWall, rightWall]);
        targets = [];
        obstacles = [];
        const def = LEVELS[(n - 1) % LEVELS.length];
        def.targets.forEach((t) =>
          targets.push(
            Bodies.circle(t.x, t.y, 20, { isStatic: true, label: "target" })
          )
        );
        def.obstacles.forEach((o) =>
          obstacles.push(
            Bodies.rectangle(o.x, o.y, o.w, o.h, {
              isStatic: true,
              angle: o.angle,
              label: "obstacle",
            })
          )
        );
        Composite.add(world, [...targets, ...obstacles]);
        triesLeft = targets.length - 1;
        triesDisplay.textContent = `Tries Left: ${triesLeft}`;
        levelDisplay.textContent = `Level: ${level}`;
        launched = false;
        projectile = null;
        updatePredictedPath();
      }

      // Predictive path
      let predictedPath = [];
      function updatePredictedPath() {
        if (launched) return;
        const a = parseFloat(angleSlider.value);
        const p = parseFloat(powerSlider.value);
        predictedPath = computePredictedPath(a, p);
      }
      function computePredictedPath(aDeg, power) {
        const temp = Engine.create();
        temp.gravity.y = engine.gravity.y;
        const ball = Bodies.circle(launcherPos.x, launcherPos.y, 12, {
          restitution: 0.6,
          frictionAir: 0.01,
        });
        Composite.add(temp.world, ball);
        const a = (aDeg * Math.PI) / 180;
        const v0 = power * VELOCITY_SCALE;
        Body.setVelocity(ball, { x: v0 * Math.cos(a), y: -v0 * Math.sin(a) });
        const pts = [];
        for (let i = 0; i < 300; i++) {
          Engine.update(temp, 1000 / 60);
          pts.push({ x: ball.position.x, y: ball.position.y });
          if (ball.position.y > 620 || ball.position.x > 820) break;
        }
        return pts;
      }
      function drawPredictedPath() {
        if (!predictedPath.length) return;
        ctx.beginPath();
        predictedPath.forEach((p, i) =>
          i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y)
        );
        ctx.strokeStyle = "rgba(0,0,0,0.45)";
        ctx.setLineDash([6, 6]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Launch logic
      function launch(aDeg, power) {
        if (launched || triesLeft <= 0) return;
        launched = true;
        triesLeft--;
        triesDisplay.textContent = `Tries Left: ${triesLeft}`;
        const a = (aDeg * Math.PI) / 180;
        projectile = Bodies.circle(launcherPos.x, launcherPos.y, 12, {
          restitution: 0.6,
          frictionAir: 0.01,
          label: "projectile",
        });
        Composite.add(world, projectile);
        const v0 = power * VELOCITY_SCALE;
        Body.setVelocity(projectile, {
          x: v0 * Math.cos(a),
          y: -v0 * Math.sin(a),
        });
        predictedPath = [];
        playSound(220, "triangle", 0.2, 0.3); // launch sound
        monitorProjectile();
      }

      function monitorProjectile() {
        const timer = setInterval(() => {
          if (!projectile) {
            clearInterval(timer);
            return;
          }
          const v = projectile.velocity;
          const speed = Math.hypot(v.x, v.y);
          if (speed < 0.2 || projectile.position.y > 580) {
            Composite.remove(world, projectile);
            projectile = null;
            launched = false;
            updatePredictedPath();
            clearInterval(timer);
            checkEndConditions();
          }
        }, 500);
      }

      // Particle system
      function spawnExplosion(x, y, color = "#f22") {
        for (let i = 0; i < 20; i++) {
          particles.push({
            x,
            y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 60,
            color,
          });
        }
      }
      function updateParticles() {
        particles.forEach((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.15;
          p.life--;
        });
        particles = particles.filter((p) => p.life > 0);
      }
      function drawParticles() {
        particles.forEach((p) => {
          ctx.globalAlpha = Math.max(0, p.life / 60);
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        });
      }

      // Level / Game flow
      function checkEndConditions() {
        const remaining = Composite.allBodies(world).filter(
          (b) => b.label === "target"
        );
        if (remaining.length === 0) {
          if (level < LEVELS.length) {
            nextLevel();
          } else {
            showWinScreen();
          }
          return;
        }
        if (triesLeft <= 0) {
          overlay.innerHTML =
            "Out of tries!<br><small>Restarting level...</small>";
          overlay.style.display = "block";
          setTimeout(() => {
            overlay.style.display = "none";
            buildLevel(level);
          }, 2000);
        }
      }

      function nextLevel() {
        overlay.innerHTML = `Level ${level} Complete!<br><small>Next level loading...</small>`;
        overlay.style.display = "block";
        score += 3;
        playSound(600, "sine", 0.3, 0.3);
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("physicsPlaygroundHighScore", highScore);
        }
        scoreDisplay.textContent = `Score: ${score}`;
        highScoreDisplay.textContent = `High Score: ${highScore}`;
        setTimeout(() => {
          overlay.style.display = "none";
          level++;
          buildLevel(level);
        }, 2000);
      }

      function showWinScreen() {
        overlay.innerHTML = `ðŸŽ‰ YOU WIN! ðŸŽ‰<br>Final Score: ${score}<br><small>Restarting...</small>`;
        overlay.style.display = "block";
        playSound(880, "square", 0.5, 0.4);
        setTimeout(() => {
          overlay.style.display = "none";
          resetGame();
        }, 3500);
      }

      function resetGame() {
        level = 1;
        score = 0;
        buildLevel(level);
        scoreDisplay.textContent = `Score: ${score}`;
        overlay.style.display = "none";
      }

      // UI
      angleSlider.addEventListener("input", updatePredictedPath);
      powerSlider.addEventListener("input", updatePredictedPath);
      launchBtn.onclick = () =>
        launch(parseFloat(angleSlider.value), parseFloat(powerSlider.value));
      resetBtn.onclick = resetGame;

      // Collisions and scoring
      Events.on(engine, "collisionStart", (e) => {
        e.pairs.forEach((p) => {
          const a = p.bodyA,
            b = p.bodyB;
          if (
            (a.label === "projectile" && b.label === "target") ||
            (b.label === "projectile" && a.label === "target")
          ) {
            const target = a.label === "target" ? a : b;
            spawnExplosion(target.position.x, target.position.y);
            playSound(440, "square", 0.2, 0.3);
            Composite.remove(world, target);
            score++;
            scoreDisplay.textContent = `Score: ${score}`;
          }
        });
      });

      // Draw loop
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!launched) drawPredictedPath();
        ctx.fillStyle = "#444";
        ctx.fillRect(launcherPos.x - 10, launcherPos.y, 20, 20);
        const bodies = Composite.allBodies(world);
        ctx.beginPath();
        bodies.forEach((b) => {
          const v = b.vertices;
          ctx.moveTo(v[0].x, v[0].y);
          for (let j = 1; j < v.length; j++) ctx.lineTo(v[j].x, v[j].y);
          ctx.lineTo(v[0].x, v[0].y);
        });
        ctx.strokeStyle = "#000";
        ctx.stroke();
        if (projectile) {
          ctx.beginPath();
          ctx.arc(
            projectile.position.x,
            projectile.position.y,
            12,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = "#a22";
          ctx.fill();
        }
        updateParticles();
        drawParticles();
        requestAnimationFrame(draw);
      }

      // Init
      buildLevel(level);
      draw();
    </script>
  </body>
</html>
