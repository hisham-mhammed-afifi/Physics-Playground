<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Physics Playground â€” Limited Tries</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body {
        background: #eef;
        margin: 0;
        overflow: hidden;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto,
          "Helvetica Neue", Arial;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 8px;
      }
      #controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      label {
        user-select: none;
      }
      canvas {
        background: #cde;
        border: 1px solid #888;
        touch-action: none;
        max-width: 100%;
        height: auto;
      }
      button {
        padding: 6px 10px;
      }
      .stat {
        margin-left: 8px;
        font-weight: 600;
      }
      #gameOverMsg {
        position: absolute;
        top: 45%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 16px 24px;
        border-radius: 8px;
        font-size: 1.2em;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label
        >Angle: <input id="angle" type="range" min="10" max="80" value="45"
      /></label>
      <label
        >Power: <input id="power" type="range" min="10" max="100" value="50"
      /></label>
      <button id="launchBtn">Launch</button>
      <button id="resetBtn">Reset</button>
      <span id="scoreDisplay" class="stat">Score: 0</span>
      <span id="triesDisplay" class="stat">Tries Left: 0</span>
      <span id="highScoreDisplay" class="stat">High Score: 0</span>
    </div>

    <canvas id="game" width="800" height="600"></canvas>
    <div id="gameOverMsg">Game Over!<br /><small>Resetting...</small></div>

    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
    <script>
      const { Engine, Runner, Bodies, Body, Composite, Events } = Matter;

      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const engine = Engine.create();
      const world = engine.world;
      const runner = Runner.create();
      Runner.run(runner, engine);

      const VELOCITY_SCALE = 0.5;
      const ground = Bodies.rectangle(400, 590, 800, 20, { isStatic: true });
      const leftWall = Bodies.rectangle(0, 300, 20, 600, { isStatic: true });
      const rightWall = Bodies.rectangle(800, 300, 20, 600, { isStatic: true });
      Composite.add(world, [ground, leftWall, rightWall]);

      // UI refs
      const angleSlider = document.getElementById("angle");
      const powerSlider = document.getElementById("power");
      const launchBtn = document.getElementById("launchBtn");
      const resetBtn = document.getElementById("resetBtn");
      const scoreDisplay = document.getElementById("scoreDisplay");
      const triesDisplay = document.getElementById("triesDisplay");
      const highScoreDisplay = document.getElementById("highScoreDisplay");
      const gameOverMsg = document.getElementById("gameOverMsg");

      // Game state
      let score = 0;
      let highScore = parseInt(
        localStorage.getItem("physicsPlaygroundHighScore") || "0"
      );
      let projectile = null;
      let launched = false;
      let triesLeft = 0;
      const launcherPos = { x: 100, y: 550 };

      highScoreDisplay.textContent = `High Score: ${highScore}`;

      // Targets & obstacles
      const targets = [
        Bodies.circle(600, 540, 20, { isStatic: true, label: "target" }),
        Bodies.circle(650, 480, 20, { isStatic: true, label: "target" }),
        Bodies.circle(700, 420, 20, { isStatic: true, label: "target" }),
      ];
      const obstacles = [
        Bodies.rectangle(400, 530, 100, 20, {
          isStatic: true,
          label: "obstacle",
        }),
        Bodies.rectangle(500, 460, 120, 20, {
          isStatic: true,
          label: "obstacle",
          angle: Math.PI / 8,
        }),
      ];
      Composite.add(world, [...targets, ...obstacles]);
      triesLeft = targets.length - 1;
      triesDisplay.textContent = `Tries Left: ${triesLeft}`;

      // Predictive path data
      let predictedPath = [];
      function updatePredictedPath() {
        if (launched) return;
        const angle = parseFloat(angleSlider.value);
        const power = parseFloat(powerSlider.value);
        predictedPath = computePredictedPath(angle, power);
      }

      // Predicted path simulation
      function computePredictedPath(angleDeg, power) {
        const tempEngine = Engine.create();
        tempEngine.gravity.y = engine.gravity.y;
        const tempBall = Bodies.circle(launcherPos.x, launcherPos.y, 12, {
          restitution: 0.6,
          frictionAir: 0.01,
        });
        Composite.add(tempEngine.world, tempBall);

        const angle = (angleDeg * Math.PI) / 180;
        const v0 = power * VELOCITY_SCALE;
        Body.setVelocity(tempBall, {
          x: v0 * Math.cos(angle),
          y: -v0 * Math.sin(angle),
        });

        const pts = [];
        for (let i = 0; i < 300; i++) {
          Engine.update(tempEngine, 1000 / 60);
          pts.push({ x: tempBall.position.x, y: tempBall.position.y });
          if (tempBall.position.y > 620 || tempBall.position.x > 820) break;
        }
        Composite.clear(tempEngine.world, false);
        return pts;
      }

      function drawPredictedPath() {
        if (!predictedPath.length) return;
        ctx.beginPath();
        predictedPath.forEach((p, i) =>
          i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y)
        );
        ctx.strokeStyle = "rgba(0,0,0,0.45)";
        ctx.setLineDash([6, 6]);
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Launch logic with tries
      function launch(angleDeg, power) {
        if (launched || triesLeft <= 0) return;
        launched = true;
        triesLeft--;
        triesDisplay.textContent = `Tries Left: ${triesLeft}`;

        const angle = (angleDeg * Math.PI) / 180;
        projectile = Bodies.circle(launcherPos.x, launcherPos.y, 12, {
          restitution: 0.6,
          frictionAir: 0.01,
          label: "projectile",
        });
        Composite.add(world, projectile);
        const v0 = power * VELOCITY_SCALE;
        Body.setVelocity(projectile, {
          x: v0 * Math.cos(angle),
          y: -v0 * Math.sin(angle),
        });
        predictedPath = [];

        // auto-reset if projectile rests or out of bounds
        monitorProjectile();
      }

      function monitorProjectile() {
        const interval = setInterval(() => {
          if (!projectile) {
            clearInterval(interval);
            return;
          }
          const v = projectile.velocity;
          const speed = Math.hypot(v.x, v.y);
          const y = projectile.position.y;
          if (speed < 0.2 || y > 580) {
            Composite.remove(world, projectile);
            projectile = null;
            launched = false;
            updatePredictedPath();
            clearInterval(interval);
            if (triesLeft <= 0) endRound();
          }
        }, 500);
      }

      function endRound() {
        gameOverMsg.style.display = "block";
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("physicsPlaygroundHighScore", highScore);
          highScoreDisplay.textContent = `High Score: ${highScore}`;
        }
        setTimeout(resetGame, 2500);
      }

      function resetGame() {
        Composite.clear(world, false);
        Composite.add(world, [
          ground,
          leftWall,
          rightWall,
          ...targets,
          ...obstacles,
        ]);
        score = 0;
        triesLeft = targets.length - 1;
        launched = false;
        projectile = null;
        scoreDisplay.textContent = "Score: 0";
        triesDisplay.textContent = `Tries Left: ${triesLeft}`;
        gameOverMsg.style.display = "none";
        updatePredictedPath();
      }

      // UI events
      angleSlider.addEventListener("input", updatePredictedPath);
      powerSlider.addEventListener("input", updatePredictedPath);
      launchBtn.onclick = () =>
        launch(parseFloat(angleSlider.value), parseFloat(powerSlider.value));
      resetBtn.onclick = resetGame;

      // Scoring
      Events.on(engine, "collisionStart", (e) => {
        e.pairs.forEach((pair) => {
          const a = pair.bodyA,
            b = pair.bodyB;
          if (
            (a.label === "projectile" && b.label === "target") ||
            (b.label === "projectile" && a.label === "target")
          ) {
            const target = a.label === "target" ? a : b;
            Composite.remove(world, target);
            score++;
            scoreDisplay.textContent = `Score: ${score}`;
          }
        });
      });

      // Render
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!launched) drawPredictedPath();

        ctx.fillStyle = "#444";
        ctx.fillRect(launcherPos.x - 10, launcherPos.y, 20, 20);

        const bodies = Composite.allBodies(world);
        ctx.beginPath();
        bodies.forEach((b) => {
          const v = b.vertices;
          ctx.moveTo(v[0].x, v[0].y);
          for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x, v[i].y);
          ctx.lineTo(v[0].x, v[0].y);
        });
        ctx.lineWidth = 1;
        ctx.strokeStyle = "#000";
        ctx.stroke();

        if (projectile) {
          ctx.beginPath();
          ctx.arc(
            projectile.position.x,
            projectile.position.y,
            projectile.circleRadius || 12,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = "#a22";
          ctx.fill();
        }
        requestAnimationFrame(draw);
      }
      draw();

      updatePredictedPath();
    </script>
  </body>
</html>
